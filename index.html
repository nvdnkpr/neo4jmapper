<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Neo4jMapper</title>
  <script src="js/jquery.min.js"></script>
  <!-- <script src="js/markdown.min.js"></script> -->
  <script src="js/showdown/showdown.js"></script>
  <script src="js/showdown/extensions/github.js"></script>
  <!-- <script src="js/rainbow/rainbow.min.js"></script>
  <script src="js/rainbow/language/javascript.js"></script>
  <script src="js/rainbow/language/coffeescript.js"></script> -->
  <script src="js/readme.js"></script>
  <link rel="stylesheet" href="http://yandex.st/highlightjs/7.3/styles/tomorrow.min.css">
  <script src="http://yandex.st/highlightjs/7.3/highlight.min.js"></script>
  
  <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" rel="stylesheet" type="text/css" />
  <link href="css/layout.css" media="all" rel="stylesheet" type="text/css" />
  <!--<link href="js/rainbow/themes/github.css" rel="stylesheet" type="text/css"> -->

</head>
<body>
<a href="https://github.com/pstaender/neo4jmapper"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
<div id="main">
# Neo4jMapper
## Object Modeler for Neo4j Graphdatabases

Written in JavaScript for browser- and serverside usage

### Why another neo4j client?

Neo4jMapper helps to get trivial neo4j-database-tasks quickly done.

Features:

  * **Querying graph, nodes and relationships** via object-chaining
  * **Object Modeling** for labeling, indexing and other schema-like behaviour 
  * **processes and transforms data** (flatten/unflatten, escaping, loading/populating …)

### Warning

**Neo4jMapper is not ready for productive environments until Neo4j v2 isn't finally released**. Neo4j v2 or above is mandatory. Currently it's tested against Neo4j Milestone 2.0.0-M05.

## How to use

### Installation

#### NodeJS

```sh
  $ npm install neo4jmapper
```
#### Browser

Include `examples/browser/neo4jmapper_complete.js` in your html-file and ensure that you have included [underscorejs](https://github.com/jashkenas/underscore/blob/master/underscore.js) and [superagent](https://github.com/visionmedia/superagent/blob/master/superagent.js) as well.

### Open Connections

```js
  var Neo4j = require('neo4jmapper');
  var neo4j = new Neo4j('http://localhost:7474');
```

or in the browser:

```js
  var neo4j = window.Neo4jMapper.init('http://localhost:7474');
```

To use multiple database instances:

```js
  var neo4j1 = new Neo4j('http://somewhere:7474');
  var neo4j2 = new Neo4j('http://elsewhere:7070');
```

## CRUD Nodes

### Create

```js
  var Node = neo4j.Node;

  new Node( { name: 'Dave Grohl', year: 1969 } ).save(function(err, dave) {
    if (err)
      console.error(err.message);
    else
      console.log('Node is persisted:', dave.toObject()); 
  });
```

Create relations between nodes:

```js
  new Node( { name: 'Foo Fighters' } ).save(function(err, fooFighters) {
    
    dave.createRelationTo(fooFighters, 'PLAYS', function(err, relationship) {
      console.log('Created Relationship:', relationship.toObject());

      new Node( { name: 'Taylor Hawkins' } ).save(function(err, taylor) {
        dave.createRelationBetween(taylor, 'ROCK', cb);
      });
    
    });
  
  });
```

Create relations with attributes:

```js
  dave.createRelationTo(fooFighters, 'PLAYS', { instrument: 'guitar' }, cb);
  taylor.createRelationTo(fooFighters, 'PLAYS', { instrument: 'drums' }, cb);
```

### Update 

```js
  console.log(dave.data.name);
  // ~> 'Dave Grohl'
  dave.data.firstName = 'Dave';
  dave.data.surname = 'Grohl';
  dave.save(cb);
```

or

```js
  Node.findById(dave.id).update({
    firstName: 'Dave',
    surname: 'Grohl'
  }, cb );
```

### Find or Create

Creates a new node with this attribute if not exists, updates if one (distinct) exists:

```js
  Node.findOrCreate({
    name: 'Dave Grohl'
  }, cb );
```

### Remove

We use `remove()` if we are on an instanced Node:

```js
  dave.remove(cb);
  // if you want to remove relationships as well
  dave.removeIncludingRelations(cb);
```

`delete()` if we perform a delete action on a query:

```js
  Node.findById(dave.id).delete(cb);
  // if you want to delete relationships as well
  Node.findById(dave.id).deleteIncludingRelations(cb);
```

### Find Nodes

Some examples:

```js
  Node.findOne({ name: 'Dave Grohl' }, function(err, dave) {
    if (err)
      console.error(err.message);
    else
      console.log('Found Node:', dave.toObject());
  });
```

```js
  Node.find({ year: 1969 }).limit(10, function(err, found) {
    if (found) {
      console.log(found.length + ' nodes found');
    }
  });
```

You can use `$and`, `$or`, `$not` and `$xor` operators in where conditions:

```js
  Node
    .find() // you can put your where condition inside find() as well
    .where( { $and: [ { year: 1969 }, { name: 'Dave Grohl'} ] } )
    .limit(1, cb);
```

Query relationships:

```js
  Node
    .findOne( { name: 'Dave Grohl' } )
    .incomingRelations('ROCKS|PLAYS', function(err, foundRelations) {
      console.log('Incoming relationships of Dave with "ROCKS" OR "PLAYS":', foundRelations);
    });
```

or query on instanced nodes:

```js
  dave.incomingRelations(function(err, relations) {
    console.log('All incoming relationships of Dave:', foundRelations);
  });
```

### Query Graph

Get processed and loaded results by using `Graph.start()…`

Here are some possible ways to go:

```js
  Graph.start().query( "CUSTOM CYPHER QUERY" , function(err, rows) {
    if (err) {
      console.error(err); // includes a stack and a reasonable error message
    } else {
      if (rows)
        for (var i=0; i < rows.length; i++) {
          console.log(rows[i].toObject());
        }
      }
    }
  });
```

Streaming gets interesting on large results:

```js
  Graph.start().stream( "CUSTOM CYPHER QUERY" , function(result) {
    if (result) {
      console.log(result.toObject());
    } else {
      console.log('Done');
    }
  });
```

Disable explicitly sort + loading to speed up response time (both are activated by default using `start()`):

```js
  Graph.start()
    .disableProcessing()
    .query( … , cb)
  // or if you want to choose what to switch on and off
  Graph.start()
    .disableLoading()
    .disableSorting()
    .query( … , cb)
```

You can chain your query elements and use conditional parameters for where clauses:

```js
  Graph
    .start()
    .match('(game:Game)-[c:contains]-(position:Position)')
    .where({ 'game.title': 'Wes vs Alvin' }) // values will be escaped
    .with('game, collect(position) AS positions')
    .match('game-[c:contains]-(position:Position)')
    .with('positions, c, position')
    .orderBy('c.move ASC')
    .match('position-[m:move]-next')
    .where('next IN (positions)')
    .return('(c.move+1)/2 as move, position.to_move as player, m.move, next.score as score')
    .limit(20, cb);
  /*
    ~>
      MATCH     (game:Game)-[c:contains]-(position:Position)
      WHERE     HAS (game.title) AND game.title = 'Wes vs Alvin'
      WITH      game, collect(position) AS positions
      MATCH     game-[c:contains]-(position:Position)
      WITH      positions, c, position
      ORDER BY  c.move ASC
      MATCH     position-[m:move]-next
      WHERE     next IN (positions)
      RETURN    (c.move+1)/2 as move, position.to_move as player, m.move, next.score as score
      LIMIT     20;
  */
```

```js
  Graph
    .start('n = node(*)')
    .case("n.eyes WHEN {color1} THEN 1 WHEN {color1} THEN 2 ELSE 3")
    .parameters({ color1: 'blue', color2: 'brown' })
    .return('n AS Person')
    .toCypherQuery();
  /* ~>
    START          n = node(*)
    CASE           n.eyes WHEN {color1} THEN 1 WHEN {color1} THEN 2 ELSE 3 END
    RETURN         n AS Person;
  */
```

Here are most of all available methods to query the graph. `…` represents the strings containing the statements:

```js
  Graph.start(…)
    .match(…)
    .onMatch(…)
    .where('n.name = {value1}')
    .parameters({value1: 'Bob'})
    .where({ 'n.name': 'Bob' }) // would save the `where(…)` and `parameters(…)` operations above
    .with(…)
    .orderBy(…)
    .skip(10)
    .limit(20)
    .delete(…)
    .return(…)
    .create(…)
    .onCreate(…)
    .createIndexOn(…)
    .createUnique(…)
    .dropIndexOn
    .merge(…)
    .remove(…)
    .set(…)
    .foreach(…)
    .case(…)
    .custom(…)
    .comment(…)
    .exec(cb) // or .stream(cb)
```

#### Direct Queries

If you want to have better performance, you can pass-through cypher queries 1:1 and get the almost native results from neo4j - almost because every result part will be parsed + transformed to a Node / Relationship / Path object.

Just start with `Graph.query(…)`:

```js
  Graph.query("START n = node(*) MATCH n-[r]-() RETURN n;", function(err, result) {
    console.log(err, result);
  });
```

Same works with stream:

```js
  Graph.stream("START n = node(*) MATCH n-[r]-() RETURN n;", function(result) {
    if (result)
      console.log(err, result);
    else
      console.log('done');
  });
```

#### Native Queries and native Results

Use `Graph.request()` to query natively:

```js
  Graph.request().query("START n = node(*) MATCH n-[r]-() RETURN n;", function(err, result) {
    console.log(err, result);
  });
  Graph.request().get("/node/123/labels", function(err, result) {
    console.log(err, result);
  });
```

### Modeling

We can define models based on the `Node` model (similar to models you might know from backbonejs for instance). 

Every extended model enjoys label support.

```js
  Node.register_model('Person', {
    fields: {
      indexes: {
        email: true
      },
      defaults: {
        created_on: function() {
          return new Date().getTime();
        }
      }
    },
    fullname: function() {
      var s = this.data.firstName + " " + this.data.surname;
      return s.trim();
    }
  }, function(err, Person) {

    var alice = new Person({firstName: 'Alice', surname: 'Springs'});

    alice.fullname();
    ~ Alice Springs

    alice.save(function(err, alice) {
      alice.toObject();
      ~ { id: 81238,
      classification: 'Node',
      data:
       { created_on: 1374758483622,
         surname: 'Springs',
         firstName: 'Alice' },
      uri: 'http://localhost:7420/db/data/node/81238',
      label: 'Person',
      labels: [ 'Person' ] }
    });

    // You can also use multiple inheritance
    // here: Director extends Person
    // Director will have the labels [ 'Director', 'Person' ]

    // You can skip the cb and work instantly with the registered model
    // if you don't use index/uid fields on your schema
    var Director = Person.register_model('Director', {
      fields: {
        defaults: {
          job: 'Director'
        }
      }
    });

    new Director({
      name: 'Roman Polanski'
    }).save(function(err, polanski) {
      polanski.toObject();
      ~ { id: 81239,
      classification: 'Node',
      data:
       { created_on: 1374758483625,
         name: 'Roman Polanski',
         job: 'Director' },
      uri: 'http://localhost:7420/db/data/node/81239',
      label: 'Director',
      labels: [ 'Director', 'Person' ] }
    });
  });

```

Coffeescript and it's class pattern is maybe the most convenient way to define models:

```coffeescript
  class Person extends Node
    fields:
      indexes:
        email: true
      defaults:
        created_on: - new Date().getTime()
    fullname: -
      s = @data.firstName + " " + @data.surname
      s.trim()

  Node.register_model Person, (err) -

    alice = new Person firstName: 'Alice', surname: 'Springs'
    alice.fullname()
    ~ 'Alice Springs'
    alice.save -
      alice.label
      ~ 'Person'

    class Director extends Person
    Node.register_model(Director)
```

### Iterate on large results (streaming)

Note: Sreaming is only working on NodeJS for now

You can iterate results asynchronously with the `each` method, it processes the stream of the response:

```js
  Node.findAll().each(function(node) {
    if (node)
      console.log(node.toObject());
    else
      console.log("Done");
  });
```

Keep in mind that there is **no extra loading executed on stream results** to keep the response time as good as possible. If you want to load a object from a streaming result (if you need labels for instance), you have to trigger it explicitly:

```js
  Person.findAll().each(function(person) {
    if (person) {
      person.load(function(err, load){
        // person is now fully loaded
        console.log(person.toObject());
      });
    }
  });
```

## Naming conventions

The query method names are heavily inspired by mongodb and mongoose - so most of them should sound familiar in case you have worked with them:

  * find, findOne, findById, findByUniqueKeyValue
  * where, whereNode, whereRelationship, whereStartNode, whereEndNode, whereRelationship, andWhereNode, …
  * andHasProperty, whereNodeHasProperty, whereRelationshipHasProperty, …
  * withRelatioships, incomingRelations, outgoingRelations, relationsBetween, incomingRelationsFrom(), outgoingRelationsTo() …
  * match
  * limit
  * skip
  * delete, deleteIncludingRelations
  * allLabels, createLabel, createLabels, replaceLabels, removeLabels
  …

Neo4jMapper is using the following identifiers in cypher queries:

  * `n` for a single [n]ode or a start node
  * `m` for an end node ([m]atch) (e.g. Node.findById(32).incomingRelationshipsFrom(12).toCypherQuery() ~ `START n = node(32), m = node(12) MATCH (n)

## Debugging

### Error messages

By default you should get clear and understandable error messages on wrong queries, e.g.:

```js
  Node.find().where("wrongQuery LIKE 'this'", function(err) {
    err ~>
      { name: 'QueryError',
        message: 'Unclosed parenthesis\n"START n = node(*)   WHERE ( wrongQuery LIKE \'this\' ) RETURN # n;"\n                                           ^',
       exception: 'SyntaxException',
       cypher: null,
       stacktrace:
        [ 'org.neo4j.cypher.internal.parser.v1_8.CypherParserImpl.parse(CypherParserImpl.scala:45)',
          'org.neo4j.cypher.CypherParser.parse(CypherParser.scala:42)',
          'org.neo4j.cypher.ExecutionEngine$$anonfun$prepare$1.apply(ExecutionEngine.scala:67)',
          'org.neo4j.cypher.ExecutionEngine$$anonfun$prepare$1.apply(ExecutionEngine.scala:67)',
          'org.neo4j.cypher.internal.LRUCache.getOrElseUpdate(LRUCache.scala:37)',
          'org.neo4j.cypher.ExecutionEngine.prepare(ExecutionEngine.scala:67)',
          'org.neo4j.cypher.ExecutionEngine.execute(ExecutionEngine.scala:59)',
          'org.neo4j.cypher.ExecutionEngine.execute(ExecutionEngine.scala:63)',
          'org.neo4j.cypher.javacompat.ExecutionEngine.execute(ExecutionEngine.java:79)',
          'org.neo4j.server.rest.web.CypherService.cypher(CypherService.java:67)',
          'java.lang.reflect.Method.invoke(Method.java:597)' ],
       statusCode: 400,
       method: 'POST',
       url: 'http://localhost:7474/db/data/cypher',
       data: '{"query":"START n = node(*)   WHERE ( wontWork LIKE \'this\' ) RETURN n;","params":{}}'
     }
  });
```

### Inspect sended + received data

In case you want to inspect sended + received data and/or the process of mapping, you can set a debug flag:

```js
  // for all instanced node(s) via prototype
  Node.prototype.neo4jrestful.debug = true;
  // or better for specific objects
  var node = new Node();
  node.neo4jrestful.debug = true;
  node.save(function(err, result, debug) {
    debug ~>
      { options: { type: 'POST', data: {}, no_processing: false, debug: true },
        requested_url: 'http://localhost:7474/db/data/node',
        type: 'POST',
        data: '{}',
        header:
         { Accept: 'application/json',
           'Content-Type': 'application/json' },
        res:
         { extensions: {},
           paged_traverse: 'http://localhost:7474/db/data/node/607/paged/traverse/{returnType}{?pageSize,leaseTime}',
           outgoing_relationships: 'http://localhost:7474/db/data/node/607/relationships/out',
           traverse: 'http://localhost:7474/db/data/node/607/traverse/{returnType}',
           all_typed_relationships: 'http://localhost:7474/db/data/node/607/relationships/all/{-list|&|types}',
           property: 'http://localhost:7474/db/data/node/607/properties/{key}',
           all_relationships: 'http://localhost:7474/db/data/node/607/relationships/all',
           self: 'http://localhost:7474/db/data/node/607',
           properties: 'http://localhost:7474/db/data/node/607/properties',
           outgoing_typed_relationships: 'http://localhost:7474/db/data/node/607/relationships/out/{-list|&|types}',
           incoming_relationships: 'http://localhost:7474/db/data/node/607/relationships/in',
           incoming_typed_relationships: 'http://localhost:7474/db/data/node/607/relationships/in/{-list|&|types}',
           create_relationship: 'http://localhost:7474/db/data/node/607/relationships',
           data: {} },
        status: 'success',
        err: null,
        responseTime: 150
      }
  });
```

or simply inspect the `_reponse_` attribute:

```js
  var node = new Node();
  node.save(function(err, result) {
    console.log(node.neo4jrestful);
  });
```

The debug object is always the third passed argument in the callback.

You can also log all network connections to the database by defining a logger:

```js
  client.constructor.prototype.log = Graph.prototype.log = function() {
    console.log(Array.prototype.slice.call(arguments).join(' '));
  }
```

### Inspect generated queries

You can easiliy inspect the generated queries by invoking the `toCypherQuery()` method:

```js
  // disable that values will be written directly into the query
  // which is in this case better for inspecting
  Node.prototype.cypher._useParameters = false;
  Node.find().andWhereNode({ name: "Bob"}).delete().toCypherQuery();
  ~> 'START n = node(*)   WHERE ( HAS (n.name) ) AND ( n.name = \'Bob\' ) DELETE n;'
```

## callback-less with generators

In v8-harmony you can use generators in your js to avoid callbacks, for instance via the suspend library:

```js
  var Neo4j = require('../src')
    , neo4j = new Neo4j('http://localhost:7474')
    , Node  = neo4j.Node
    , Graph = neo4j.Graph
    , suspend = require('suspend');

  suspend(function*(resume) {
    var Band = yield Node.register_model('Band', resume);
    var Song = yield Node.register_model('Song', resume);
    var band = yield new Band({ name: 'Foo Fighter'}).save(resume);
    var song = yield new Song({ title: 'Everlong' }).save(resume);
    yield band.createRelationshipTo(song, 'plays', resume);
    var relations = yield song.incomingRelationships('plays', resume);
    console.log(relations[0].toObject());
  })();
```

## Schema like behaviour

Neo4jMapper is not a schema-based-mapper, but it includes some features which are similar to this.

### Default values, unique fields and autoindex

To let buil Neo4j the index in the background for you, you just have to define the fields in the `indexes` property as you see below. If you want to ensure that the field is unique, add the fields to the `unique` property (keep in mind that unique fields are always ”indexes“ as well). The default properties has no effect on the database, it just will populate the object with default values if they aren't set.

```js
  Node.register_model('Person', {
    fields = {
      defaults: {
        is_new: true,
        uid: -> new Date().getTime()
      },
      indexes: {
        email: true,
        uid: 'my_person_index'
      },
      unique: {
        uid: true
      }
    }
  }, function(err, Person) {
    // work with the registered and indexed model 'Person'
    var polanski = new Person();
  });
```

```coffeescript

  class Person extends Node

    fields: {
      defaults: {
        is_new: true
        # default values will be generated with invoking this method (e.g. generating a timestamp)
        uid: -> new Date().getTime()
      },
      indexes: {
        email: true # will be autoindex
        uid: 'my_person_index' # will be indexed on the legacy way with 'my_person_index' namespace 
      }
    }

  Node.register_model Person, (err) ->
    polanski = new Person()
```

### Drop indexes

Neo4jMapper won't drop indexed or unique defined fields for you, because it doesn't have any migration features. But you can drop the index on a Model by yourself via:

```js
  Node.register_model('Person', function(err, Person) {
    Person.dropEntireIndex(function(err, Per) {
      console.log("Dropped entire index for label 'Person'");
    });
  }); 
```

## Hooks

### Nodes

All hooks can also be defined for specific ”classes“, e.g.:

```js
  Person.prototype.onBeforeSave = fucntion(next) { next(null, null); }
```

#### onBeforeSave

```js
  Node.prototype.onBeforeSave = function(next) {
    // do s.th. before the node will be persisted
    // is called before initially save and update
    next();
  }
```

#### onBeforeRemove

```js
  Node.prototype.onBeforeRemove = function(next) {
    // do s.th. before the node will be removed
    next();
  }
```

#### onBeforeInitialize

Called once the model is being registered. For instance, to ensure autoindex on defined fields is done in this part:

```js
  Node.prototype.onBeforeInitialize = function(next) {
    // do s.th. before the Model gets initialized
    next();
  }
```

#### onAfterLoad

On all `Node.find…()` queries the results run through a load process (loading the label(s) which has to be an extra request for instance). You can define your own afterLoad process this way:

```js
  Node.prototype.onAfterLoad = function(node, done) {
    // do s.th. here, finnaly call done()
    if (node.id)
      this.neo4jrestful.query("START …", function(err, result) {
        // …
        done(err, null);
      });
  }
```

#### onAfterPopulate

If a node is populated with data from a response, you can process your node/data here. This method is called synchronous.

```js
  Node.prototype.onAfterPopulate = function() {
    if ((this.data.firstname)&&(this.data.surname)) {
      this.data.name = this.data.firstname + ' ' + this.data.surname;
    }
  }
```

### Performance Tweaks

To reduce database requests you can switch load hooks on and off

  * `Node.prototype.disableLoading()` / `Node.prototype.enableLoading()` 
  * `Node.disable_loading()` / `Node.enable_loading()` in global context

### Benchmarks

Some basic benchmark tests are written. To get reasonable benchmark results we compare neo4jmapper with the node-neo4j library (a robust basic neo4j driver). You can execute them with `coffee benchmark/benchmark.coffee` (beware that a lot of nodes will be written and kept in your database).
</div>
</body>
</html>