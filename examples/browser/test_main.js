// Generated by CoffeeScript 1.6.2
var Graph, Join, Neo4j, Node, client, configForTest, expect, graphdb, helpers, neo4jmapper, version, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (typeof root !== "undefined" && root !== null) {
  require('source-map-support').install();
  expect = require('expect.js');
  Join = require('join');
  _ = require('underscore');
  configForTest = require('./config');
  Neo4j = require('../src/index.js');
  _ref = new Neo4j(configForTest.neo4jURL), Graph = _ref.Graph, Node = _ref.Node, helpers = _ref.helpers, client = _ref.client;
} else if (typeof window !== "undefined" && window !== null) {
  configForTest = _.extend({
    doLog: false,
    wipeDatabase: false,
    neo4jURL: 'http://yourserver:0000/',
    startInstantly: false
  }, configForTest || {});
  Join = window.Join;
  neo4jmapper = Neo4jMapper.init(configForTest.neo4jURL);
  Graph = neo4jmapper.Graph, Node = neo4jmapper.Node, helpers = neo4jmapper.helpers, client = neo4jmapper.client;
  Neo4j = Neo4jMapper.init;
}

if (configForTest.doLog) {
  client.constructor.prototype.log = Graph.prototype.log = configForTest.doLog;
}

version = client.version;

graphdb = null;

client.checkAvailability(function(err) {
  if (err) {
    throw err;
  }
  return version = client.version;
});

describe('Neo4jMapper', function() {
  before(function(done) {
    graphdb = new Graph(configForTest.neo4jURL);
    return done();
  });
  describe('graph', function() {
    it('expect to create a graph object, with all variants of arguments', function(done) {
      var join, neo4j;

      join = Join.create();
      neo4j = new Neo4j({
        url: configForTest.neo4jURL
      });
      neo4j.client.checkAvailability(join.add());
      neo4j = new Neo4j(configForTest.neo4jURL);
      neo4j.client.checkAvailability(join.add());
      return join.when(function() {
        var arg, _i, _len, _ref1;

        _ref1 = Array.prototype.slice.apply(arguments);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          arg = _ref1[_i];
          expect(arg[0]).to.be(null);
          expect(arg[1]).to.be.a('string');
        }
        return done();
      });
    });
    it("expect " + (configForTest.wipeDatabase ? "" : "not ") + "to remove all nodes and relationships from the database", function(done) {
      var graph;

      if (!configForTest.wipeDatabase) {
        return done();
      }
      graph = new Graph();
      return graph.wipeDatabase(function(err, res) {
        expect(err).to.be(null);
        return done();
      });
    });
    it('expect to get information about the server', function(done) {
      var graph;

      graph = new Graph();
      return graph.about(function(err, data) {
        expect(err).to.be(null);
        expect(graph.info).to.be.an('object');
        return done();
      });
    });
    it('expect to get a neo4j version value', function(done) {
      var graph;

      graph = new Graph();
      return graph.about(function() {
        expect(client.version).to.be.a('number');
        expect(client.version >= 2).to.be(true);
        expect(client.exact_version).to.be.a('string');
        return done();
      });
    });
    it('expect to count all nodes in database', function(done) {
      var graph;

      graph = new Graph();
      return graph.countNodes(function(err, count) {
        expect(err).to.be(null);
        expect(count).to.be.a('number');
        return done();
      });
    });
    it('expect to count all relationships in database', function(done) {
      var graph;

      graph = new Graph();
      return graph.countRelationships(function(err, count) {
        expect(err).to.be(null);
        expect(count).to.be.a('number');
        return done();
      });
    });
    return it('expect to count all nodes + relationships in database', function(done) {
      var count, graph;

      graph = new Graph();
      count = 0;
      return graph.countNodes(function(err, countNodes) {
        count += countNodes;
        return graph.countRelationships(function(err, countRelationships) {
          count += countRelationships;
          return graph.countAll(function(err, count) {
            expect(err).to.be(null);
            expect(count).to.be.equal(count);
            return done();
          });
        });
      });
    });
  });
  describe('node', function() {
    it('expect to allow inheritance', function(done) {
      var Person, movie, person, _ref1;

      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        Person.prototype.data = {
          label: 'a Person'
        };

        return Person;

      })(Node);
      person = new Person();
      expect(person).to.be.an('object');
      expect(person.id).to.be(null);
      expect(person.cypher.label).to.be('Person');
      expect(person.constructor_name).to.be('Person');
      var Movie = (function(Node) {

      function Movie() {
        // this is necessary to give the constructed node a name context
        this.init.apply(this, arguments);
      }
      
      _.extend(Movie.prototype, Node.prototype);
      
      Movie.prototype.label = Movie.prototype.constructor_name = 'Movie';

      Movie.prototype.fields = {
        defaults: {
          genre: 'Blockbuster'
        }
      };
      
      return Movie;
    })(Node);
      movie = new Movie();
      expect(movie.label).to.be.equal('Movie');
      expect(movie.constructor_name).to.be.equal('Movie');
      expect(movie).to.be.an('object');
      expect(movie.id).to.be(null);
      return done();
    });
    it('expect to create a node', function(done) {
      var node;

      node = new Node({
        title: new Date().toString()
      });
      return node.save(function(err, storedNode) {
        var id;

        id = node.id;
        expect(err).to.be(null);
        expect(storedNode.data.title).to.be(node.data.title);
        expect(storedNode.id).to.be.above(0);
        return Node.prototype.findById(id, function(err, found) {
          expect(found).to.be.an('object');
          expect(found.id).to.be.equal(id);
          expect(found.data.title).to.be.equal(node.data.title);
          return node.remove(function() {
            return done();
          });
        });
      });
    });
    it('expect to find one specific node by id', function(done) {
      var node;

      node = new Node({
        title: new Date().toString()
      });
      return node.save(function() {
        return Node.prototype.findById(node.id, function(err, found) {
          expect(err).to.be(null);
          expect(found.data.title).to.be.equal(node.data.title);
          expect(found.id).to.be.equal(node.id);
          return node.remove(function() {
            return done();
          });
        });
      });
    });
    it('expect to find one specific node by key/value', function(done) {
      var node;

      node = new Node({
        title: new Date().toString()
      });
      return node.save(function() {
        return Node.prototype.findByUniqueKeyValue('title', node.data.title, function(err, found) {
          expect(err).to.be(null);
          expect(found.data.title).to.be.equal(node.data.title);
          expect(found.id).to.be.equal(node.id);
          return node.remove(function() {
            return done();
          });
        });
      });
    });
    it('expect to get null as result if one specific node is not found', function(done) {
      return Node.prototype.findOne({
        SomeKey: new Date().getTime()
      }, function(err, found) {
        expect(err).to.be(null);
        expect(found).to.be(null);
        return done();
      });
    });
    it('expect to find many nodes with different labels', function(done) {
      var groupid;

      groupid = new Date().getTime();
      return new Node({
        name: 'Alice',
        group_id: groupid
      }).addLabel('Person').save(function(err, alice) {
        expect(err).to.be(null);
        expect(alice.label).to.be('Person');
        expect(alice.labels[0]).to.be('Person');
        return new Node({
          name: 'Bob',
          group_id: groupid
        }).addLabel('Developer').save(function(err, bob) {
          expect(err).to.be(null);
          expect(bob.label).to.be('Developer');
          expect(bob.labels[0]).to.be('Developer');
          return Node.prototype.find({
            group_id: groupid
          }, function(err, nodes) {
            var Developer, _ref1;

            expect(err).to.be(null);
            expect(nodes).to.have.length(2);
            expect(nodes[0].constructor_name).to.be.equal('Node');
            expect(nodes[1].constructor_name).to.be.equal('Node');
            Developer = (function(_super) {
              __extends(Developer, _super);

              function Developer() {
                _ref1 = Developer.__super__.constructor.apply(this, arguments);
                return _ref1;
              }

              return Developer;

            })(Node);
            Node.prototype.register_model(Developer);
            return Developer.prototype.find({
              group_id: groupid
            }, function(err, nodes) {
              expect(err).to.be(null);
              expect(nodes).to.have.length(1);
              expect(nodes[0].data.name).to.be.equal('Bob');
              return done();
            });
          });
        });
      });
    });
    it('expect to remove a node', function(done) {
      var node;

      node = new Node({
        title: 'test'
      });
      return node.save(function() {
        return graphdb.countNodes(function(err, countNodesBefore) {
          return node.remove(function(err) {
            return graphdb.countNodes(function(err, countNodesAfter) {
              var id;

              id = node.id;
              expect(err).to.be(null);
              expect(countNodesBefore - 1).to.be(countNodesAfter);
              return done();
            });
          });
        });
      });
    });
    it('expect to query customized via cypher', function(done) {
      var graph;

      graph = new Graph();
      return graph.query("START nodes=node(*)\nRETURN nodes LIMIT 10;", function(err, results) {
        expect(err).to.be(null);
        expect(results.columns.length).to.be.a('number');
        expect(results.data.length).to.be.a('number');
        return done();
      });
    });
    it('expect to get suitable errors on wrong customized cypher queries', function(done) {
      var graph;

      graph = new Graph();
      return graph.query("START nodes=node(*)\nRETURN nodes LIMITS 10;", function(err, results) {
        expect(err.message).to.be.a('string');
        expect(err.stacktrace.length).to.be.a('number');
        return done();
      });
    });
    it('expect to get suitable error on wrong mapper cypher queries', function(done) {
      return Node.prototype.findOne().where("thisWillProduceAnError BECAUSE 'it\'s not a valid cypher query at all'", function(err) {
        expect(err).to.be.an('object');
        expect(/unclosed\s+parenth/i.test(err.message)).to.be(true);
        expect(/SyntaxException/i.test(err.exception)).to.be(true);
        return done();
      });
    });
    it('expect to get all nodes', function(done) {
      var n;

      n = new Node();
      n = n.findAll().limit(100).where("HAS (n.collection) AND n.collection = 'users'");
      return n.stream(function(err, data) {
        n = new Node();
        n = n.findAll().limit(10).whereHasProperty('collection').andWhere("n.collection = 'users'");
        return n.stream(function(err, found) {
          n = n.findAll().limit(10).where([
            {
              $and: [
                {
                  'HAS (n.collection)': 'HAS (n.collection)'
                }, {
                  'n.collection': /^users$/i
                }
              ]
            }
          ]);
          return n.exec(function() {
            return done();
          });
        });
      });
    });
    it('expect to get null if node is not found', function(done) {
      return Node.prototype.findById(1234567890, function(err, found) {
        expect(err).to.be(null);
        expect(found).to.be(null);
        return Node.prototype.findByUniqueKeyValue({
           key: new Date().getTime()
        }, function(err, found) {
          expect(err).to.be(null);
          expect(found).to.be(null);
          return done();
        });
      });
    });
    it('expect to process data between javascript and neo4j as good as possible', function(done) {
      var n;

      n = new Node();
      n.data = {
        title: 'Hello World',
        whatever: {
          nested: 'pinguin'
        },
        numberArray: [1, 2, 3],
        stringArray: ['a', 'b', 'c'],
        complexObject: [
          {
            a: true
          }
        ],
        other: {
          nested: ['A']
        }
      };
      return n.save(function(err, node) {
        var id;

        id = node.id;
        expect(node.data.title).to.be.equal(n.data.title);
        expect(node.data.numberArray.constructor).to.be.equal(Array);
        expect(node.data.complexObject[0].a).to.be(true);
        expect(node.data.other.nested).to.have.length(1);
        return done();
      });
    });
    it('expect to update a node', function(done) {
      return new Node({
        title: 'Hello World!'
      }).save(function(err, node) {
        var id;

        expect(node.data.title).to.be.equal('Hello World!');
        id = node.id;
        return Node.prototype.findById(id, function(err, found) {
          found.data.title = 'How are you?';
          return found.update(function(err, savedNode) {
            expect(savedNode.data.title).to.be.equal('How are you?');
            expect(err).to.be(null);
            return Node.prototype.findById(id, function(err, foundAgain) {
              expect(foundAgain.data.title).to.be(found.data.title);
              return foundAgain.removeWithRelationships(function(err) {
                expect(err).to.be(null);
                return node.remove(function() {
                  return done();
                });
              });
            });
          });
        });
      });
    });
    it('expect to update data of a node with changing accidently id', function(done) {
      return new Node({
        name: 'Dave Grohl',
        origin: {
           country: 'USA',
          state: ''
        }
      }).save(function(err, dave) {
        var id;

        expect(err).to.be(null);
        expect(dave.data.name).to.be.equal('Dave Grohl');
        expect(dave.data.origin.state).to.be.equal('');
        expect(dave.data.origin.country).to.be.equal('USA');
        id = dave.id;
        dave.id = -2;
        expect(id).to.be.above(0);
        return dave.update({
          origin: {
            state: 'Ohio'
          }
        }, function(err, daveSaved) {
          expect(err).to.be(null);
          expect(dave.data.name).to.be.equal('Dave Grohl');
          expect(dave.data.origin.state).to.be.equal('Ohio');
          expect(dave.data.origin.country).to.be(void 0);
          expect(dave.id).to.be(id);
          return done();
        });
      });
    });
    it('expect to execute onBeforeSave hook if defined', function(done) {
      var n;

      n = new Node();
      n.called_on_before_save = false;
      n.onBeforeSave = function(self, next) {
        n.called_on_before_save = true;
        return next();
      };
      return n.save(function(err) {
        expect(err).to.be(null);
        expect(n.called_on_before_save).to.be(true);
        return n.remove(function() {
          return done();
        });
      });
    });
    return it('expect to execute onBeforeRemove hook if defined', function(done) {
      var n;

      n = new Node();
      n.called_on_before_remove = false;
      n.onBeforeRemove = function(next) {
        n.called_on_before_remove = true;
        return next();
      };
      return n.save(function(err) {
        expect(n.called_on_before_remove).to.be(false);
        return n.remove(function(err) {
          expect(err).to.be(null);
          expect(n.called_on_before_remove).to.be(true);
          return done();
        });
      });
    });
  });
  describe('classes and models', function() {
    it('expect to register and unregister models for nodes', function() {
      var Person, _ref1;

      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Person;

      })(Node);
      Node.prototype.register_model(Person);
      expect(Node.prototype.registered_models()['Person'].constructor).to.be(Person.constructor);
      Node.prototype.unregister_model(Person);
      expect(Node.prototype.registered_models()['Person']).to.be(void 0);
      Node.prototype.register_model(Person);
      Node.prototype.unregister_model('Person');
      return expect(Node.prototype.registered_models()['Person']).to.be(void 0);
    });
    it('expect to find corresponding node to each model', function(done) {
      var Movie, _ref1;

      Movie = (function(_super) {
        __extends(Movie, _super);

        function Movie() {
          _ref1 = Movie.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Movie;

      })(Node);
      Node.prototype.register_model(Movie);
      return Movie.prototype.findAll().count(function(err, countBefore) {
        var lebowski;

        expect(err).to.be(null);
        expect(countBefore).to.be.a('number');
        lebowski = new Movie({
          title: 'The Big Lebowski'
        });
        return lebowski.save(function(err, lebowski) {
          expect(_.keys(lebowski.data)).to.have.length(1);
          expect(err).to.be(null);
          return Movie.prototype.findAll().count(function(err, countNow) {
            expect(countBefore + 1).to.be(countNow);
            return lebowski.remove(function() {
              return done();
            });
          });
        });
      });
    });
    it('expect to convert to specific models', function(done) {
      var Director, _ref1;

      Director = (function(_super) {
        __extends(Director, _super);

        function Director() {
          _ref1 = Director.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Director;

      })(Node);
      return new Director({
        name: 'Robert Zemeckis'
      }).save(function(err, robert) {
        expect(err).to.be(null);
        expect(robert.constructor_name).to.be('Director');
        expect(robert.label).to.be('Director');
        return Node.prototype.findById(robert.id, function(err, found) {
          expect(found.label).to.be.equal('Director');
          Node.prototype.register_model(Director);
          found = Node.prototype.convert_node_to_model(found, Director);
          expect(found.constructor_name).to.be.equal('Director');
          return done();
        });
      });
    });
    it('expect to autoindex models', function(done) {
      /*
        TODO: autoindex check for indexed field tests
      */

      var Movie, _ref1;

      Movie = (function(_super) {
        __extends(Movie, _super);

        function Movie() {
          _ref1 = Movie.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        Movie.prototype.fields = {
          indexes: {
            uid: true,
            nested: {
              id: true
            }
          }
        };

        return Movie;

      })(Node);
      return Node.prototype.register_model(Movie, function(err, result) {
        var deathAndMaiden, error, uid, _i, _len;

        if (err) {
          expect(err.constructor).to.be(Array);
          for (_i = 0, _len = err.length; _i < _len; _i++) {
            error = err[_i];
            expect(error.cause.exception).to.be.equal('AddIndexFailureException');
          }
        }
        deathAndMaiden = new Movie({
          title: 'Death and the Maiden'
        });
        uid = new Date().getTime();
        deathAndMaiden.data.uid = uid;
        return deathAndMaiden.save(function(err) {
          expect(err).to.be(null);
          return Movie.prototype.findAll().where({
            uid: uid
          }, function(err, found) {
            expect(err).to.be(null);
            expect(found).to.have.length(1);
            expect(found[0].data.uid).to.be.equal(uid);
            return deathAndMaiden.remove(function() {
              return done();
            });
          });
        });
      });
    });
    it('expect to have unique values');
    return it('expect to det default values on models', function(done) {
      var Movie, bitterMoon, _ref1;

      Movie = (function(_super) {
        __extends(Movie, _super);

        function Movie() {
          _ref1 = Movie.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        Movie.prototype.fields = {
          indexes: {
            uid: true
          },
          defaults: {
            uid: function() {
              return new Date().getTime();
            },
            is_movie: true,
            director: 'Roman Polanski'
          }
        };

        return Movie;

      })(Node);
      Node.prototype.register_model(Movie);
      bitterMoon = new Movie({
        title: 'Bitter Moon'
      });
      return bitterMoon.save(function(err) {
        var uid;

        expect(err).to.be(null);
        uid = bitterMoon.data.uid;
        expect(uid).to.be.a('number');
        return Movie.prototype.findAll().where({
          uid: uid
        }, function(err, found) {
          expect(err).to.be(null);
          expect(found).to.have.length(1);
          expect(found[0].data.uid).to.be.equal(uid);
          expect(found[0].data.title).to.be.equal('Bitter Moon');
          expect(found[0].data.is_movie).to.be(true);
          expect(found[0].data.director).to.be.equal('Roman Polanski');
          expect(_.keys(found[0].data)).to.have.length(4);
          return bitterMoon.remove(function() {
            return done();
          });
        });
      });
    });
  });
  describe('label nodes', function() {
    it('expect to save labeled node and request label(s)', function(done) {
      var node;

      node = new Node({
        name: 'Dave'
      });
      node.label = 'Person';
      return node.save(function(err, person, debug) {
        expect(err).to.be(null);
        expect(person.label).to.be.equal('Person');
        return node.requestLabels(function(err, labels) {
          expect(err).to.be(null);
          expect(labels).to.have.length(1);
          expect(labels[0]).to.be.equal('Person');
          return node.remove(function(err) {
            var Article, article, _ref1;

            expect(err).to.be(null);
            Article = (function(_super) {
              __extends(Article, _super);

              function Article() {
                _ref1 = Article.__super__.constructor.apply(this, arguments);
                return _ref1;
              }

              return Article;

            })(Node);
            article = new Article({
              title: 'Title of the article'
            });
            return article.save(function() {
              return article.requestLabels(function(err, labels) {
                expect(labels).to.have.length(1);
                expect(labels[0]).to.be.equal('Article');
                return article.remove(function() {
                  return done();
                });
              });
            });
          });
        });
      });
    });
    it('expect to add, remove and update labels of a node', function(done) {
      var Person, p, _ref1;

      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        Person.prototype.fields = {
          defaults: {},
          indexes: {}
        };

        return Person;

      })(Node);
      p = new Person({
        name: 'Jeff Bridges'
      });
      Node.prototype.register_model(Person);
      return new Person({
        name: 'Jeff Bridges'
      }).save(function(err, jeff) {
        return jeff.allLabels(function(err, labels) {
          expect(err).to.be(null);
          expect(labels).to.have.length(1);
          expect(_.keys(jeff.data)).to.have.length(1);
          expect(labels[0]).to.be.equal('Person');
          return jeff.addLabel('Actor', function(err) {
            expect(err).to.be(null);
            return jeff.addLabels(['Actor', 'Singer', 'Photographer'], function(err) {
              return jeff.allLabels(function(err, labels) {
                expect(err).to.be(null);
                expect(labels).to.have.length(4);
                return jeff.replaceLabels(['Person'], function(err) {
                  expect(err).to.be(null);
                  return jeff.allLabels(function(err, labels) {
                    expect(err).to.be(null);
                    expect(labels).to.have.length(1);
                    expect(labels[0]).to.be.equal('Person');
                    return Person.prototype.findOne().where({
                      name: 'Jeff Bridges'
                    }, function(err, found) {
                      expect(err).to.be(null);
                      return found.load(function(err, jeff) {
                        expect(jeff.label).to.be.equal('Person');
                        expect(jeff.labels).to.have.length(1);
                        expect(jeff.labels[0]).to.be.equal('Person');
                        return done();
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
    it('expect to find labeled node, with and without class', function(done) {
      var Person, person, _ref1;

      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Person;

      })(Node);
      person = new Person({
        name: 'Dave'
      });
      return person.save(function(err, savedPerson, debug) {
        expect(person.label).to.be.equal('Person');
        expect(savedPerson.label).to.be.equal('Person');
        return done();
      });
    });
    it('expect to find node including labels', function(done) {
      var Person, _ref1;

      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Person;

      })(Node);
      Node.prototype.register_model(Person);
      return new Person({
        name: 'Alice'
      }).save(function(err, alice) {
        return Person.prototype.findById(alice.id, function(err, alice) {
          expect(alice.constructor_name).to.be.equal('Person');
          expect(alice.label).to.be.equal('Person');
          return done();
        });
      });
    });
    return it('expect to find labeled nodes', function(done) {
      var Person, person, _ref1;

      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Person;

      })(Node);
      person = new Person({
        name: 'Dave'
      });
      return Node.prototype.findAll().match('n:Person').count(function(err, countBefore) {
        return person.save(function() {
          return Node.prototype.findAll().match('n:Person').count(function(err, count) {
            expect(err).to.be(null);
            expect(count).to.be.equal(countBefore + 1);
            return done();
          });
        });
      });
    });
  });
  describe('index', function() {
    it('expect to index and get an indexed node', function(done) {
      var node, uid;

      node = new Node();
      uid = new Date().getTime();
      node.data.name = 'Peter';
      node.data.city = 'Berlin';
      return node.addIndex('test', 'city', 'cologne', function(err) {
        expect(err.message).to.be.equal('You need to persist the node before you can index it.');
        return node.save(function(err, savedNode) {
          expect(err).to.be(null);
          return savedNode.addIndex('test', 'uid', uid, function(err, result) {
            expect(err).to.be(null);
            return node.findByIndex('test', 'uid', uid, function(err, result) {
              expect(err).to.be(null);
              expect(result.id).to.be(savedNode.id);
              return done();
            });
          });
        });
      });
    });
    return it('expect to set default values and index values', function(done) {
      var node;

      Node.prototype.fields.defaults = {
        uid: function() {
          return new Date().getTime();
        },
        nested: {
          hasValue: true
        }
      };
      node = new Node();
      node.data.name = 'Steve';
      return node.save(function(err) {
        expect(err).to.be(null);
        expect(node.data.uid).to.be.above(0);
        expect(node.data.nested.hasValue).to.be(true);
        Node.prototype.fields.indexes.uid = 'collection';
        node = new Node();
        node.data.name = 'Bill';
        return node.save(function(err) {
          var uid;

          uid = node.data.uid;
          expect(err).to.be(null);
          return Node.prototype.findByIndex('collection', 'uid', uid, function(err, found) {
            expect(err).to.be(null);
            expect(found.data.uid).to.be.equal(uid);
            return done();
          });
        });
      });
    });
  });
  describe('relationships (incoming, outgoing and between nodes)', function() {
    it('expect to create a relationship between nodes in any direction', function(done) {
      var alice, bob;

      alice = new Node({
        name: 'Alice'
      });
      bob = new Node({
        name: 'Bob'
      });
      return alice.save(function() {
        return bob.save(function() {
          return graphdb.countRelationships(function(err, countedRelationshipsBefore) {
            return alice.createRelationshipBetween(bob, 'knows', {
              since: 'years'
            }, function(err, result) {
              expect(err).to.be(null);
              expect(result).to.have.length(2);
              return graphdb.countRelationships(function(err, countedRelationshipsIntermediate) {
                expect(countedRelationshipsBefore + 2).to.be.equal(countedRelationshipsIntermediate);
                return bob.createRelationshipTo(alice, 'liked', function(err, relationship) {
                  expect(err).to.be(null);
                  expect(relationship).to.be.an('object');
                  expect(relationship.type).to.be.equal('liked');
                  expect(relationship).to.be.an('object');
                  return graphdb.countRelationships(function(err, countedRelationshipsFinally) {
                    expect(countedRelationshipsBefore + 3).to.be.equal(countedRelationshipsFinally);
                    return bob.createRelationshipFrom(alice, 'follows', function(err, relationship) {
                      expect(err).to.be(null);
                      expect(relationship).to.be.an('object');
                      return graphdb.countRelationships(function(err, countedRelationshipsFinally) {
                        expect(countedRelationshipsBefore + 4).to.be.equal(countedRelationshipsFinally);
                        return bob.createOrUpdateRelationshipFrom(alice, 'follows', {
                          since: 'years'
                        }, function(err, relationship) {
                          var id;

                          expect(err).to.be(null);
                          expect(relationship).to.be.an('object');
                          expect(relationship.type).to.be.equal('follows');
                          expect(relationship.data.since).to.be.equal('years');
                          expect(relationship.id).to.be.a('number');
                          id = relationship.id;
                          return graphdb.countRelationships(function(err, count) {
                            expect(count).to.be.equal(countedRelationshipsFinally);
                            return bob.createOrUpdateRelationshipFrom(alice, 'follows', {
                              since: 'months'
                            }, function(err, relationship) {
                              expect(err).to.be(null);
                              expect(relationship).to.be.an('object');
                              expect(relationship.type).to.be.a('string');
                              expect(relationship.data.since).to.be.equal('months');
                              expect(relationship.id).to.be.equal(id);
                              return graphdb.countRelationships(function(err, count) {
                                expect(count).to.be.equal(countedRelationshipsFinally);
                                return alice.removeWithRelationships(function() {
                                  return bob.removeWithRelationships(function() {
                                    return done();
                                  });
                                });
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
    return it('expect to create and get incoming, outgoing and bidirectional relationships between two nodes', function(done) {
      var node;

      node = new Node();
      node.data.name = "Alice";
      return node.save(function(err, a) {
        expect(a.hasId()).to.be(true);
        return a.outgoingRelationships().count(function(err, count) {
          expect(count).to.be(0);
          node = new Node();
          node.data.name = "Bob";
          return node.save(function(err, b) {
            expect(b.hasId()).to.be(true);
            return a.createRelationshipTo(b, 'KNOWS', {
              since: 'years'
            }, function(err, result) {
              expect(err).to.be(null);
              return a.outgoingRelationships().count(function(err, countNew) {
                expect(countNew).to.be(1);
                a.neo4jrestful.debug = true;
                return a.outgoingRelationships(function(err, outgoingRelationships, debug) {
                  expect(err).to.be(null);
                  expect(outgoingRelationships).to.have.length(1);
                  expect(outgoingRelationships[0].type).to.be.equal('KNOWS');
                  expect(outgoingRelationships[0].data.since).to.be.equal('years');
                  expect(outgoingRelationships[0].from).to.be.an('object');
                  expect(outgoingRelationships[0].from.id).to.be.a('number');
                  expect(outgoingRelationships[0].from.uri).to.be.a('string');
                  expect(outgoingRelationships[0].to).to.be.an('object');
                  expect(outgoingRelationships[0].to.id).to.be.a('number');
                  expect(outgoingRelationships[0].to.uri).to.be.a('string');
                  expect(outgoingRelationships[0].toObject()).to.be.an('object');
                  return a.createRelationshipFrom(b, 'LIKES', function(err, result) {
                    expect(err).to.be(null);
                    return a.incomingRelationships('LIKES', function(err, result) {
                      expect(outgoingRelationships).to.have.length(1);
                      expect(err).to.be(null);
                      a.neo4jrestful.debug = true;
                      return a.createRelationshipBetween(b, 'LIKES', function(err, result, debug) {
                        expect(err).to.be(null);
                        return a.allRelationships('LIKES', function(err, result) {
                          expect(err).to.be(null);
                          expect(result).to.have.length(3);
                          return done();
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
  describe('path algorithms', function() {
    return it('expect to find shortest path from one node to an other node', function(done) {
      var a;

      a = new Node({
        name: 'Alice'
      });
      return a.save(function(err) {
        var b;

        b = new Node({
          name: 'Bob'
        });
        return b.save(function() {
          var c;

          c = new Node({
            name: 'Charles'
          });
          return c.save(function() {
            return a.createRelationshipTo(b, 'KNOWS', function() {
              return b.createRelationshipTo(c, 'KNOWS', function() {
                a.neo4jrestful.debug = true;
                return a.shortestPathTo(c, 'KNOWS', function(err, path, debug) {
                  expect(err).to.be(null);
                  expect(path.length).to.be(2);
                  expect(path.nodes).to.have.length(3);
                  expect(path.nodes[0].uri).to.be.a('string');
                  expect(path.nodes[0].id).to.be.a('number');
                  expect(path.relationships).to.have.length(2);
                  expect(path.relationships[0].uri).to.be.a('string');
                  expect(path.relationships[0].id).to.be.a('number');
                  expect(path.start).to.be.a('string');
                  expect(path.end).to.be.a('string');
                  expect(path.toObject()).to.be.an('object');
                  return a.removeWithRelationships(function(err) {
                    expect(err).to.be(null);
                    return b.removeWithRelationships(function(err) {
                      expect(err).to.be(null);
                      return done();
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
  describe('relationship', function() {
    it('expect to get a relationship by id, update and remove it', function(done) {
      return new Node().save(function(err, a) {
        return new Node().save(function(err, b) {
          return a.createRelationshipTo(b, 'related', {
            since: 'year'
          }, function(err, result) {
            expect(result.id).to.be.above(0);
            return Relationship.prototype.findById(result.id, function(err, found) {
              expect(err).to.be(null);
              expect(found.id).to.be.equal(result.id);
              expect(found.data.since).to.be.equal('year');
              found.data = {
                from: 'Berlin'
              };
              return found.save(function(err) {
                expect(err).to.be(null);
                return Relationship.prototype.findById(result.id, function(err, found) {
                  expect(err).to.be(null);
                  expect(found.data.since).to.be(void 0);
                  expect(found.data.from).to.be.equal('Berlin');
                  return found.remove(function(err) {
                    expect(err).to.be(null);
                    return Relationship.prototype.findById(result.id, function(err, found) {
                      expect(err).to.be(null);
                      expect(found).to.be(null);
                      return done();
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
    it('expect to trigger load hook and loading both nodes on getById', function(done) {
      return new Node({
        name: 'Alice'
      }).save(function(err, a) {
        return new Node({
          name: 'Bob'
        }).save(function(err, b) {
          return a.createRelationshipTo(b, 'related', {
            since: 'year'
          }, function(err, result) {
            expect(err).to.be(null);
            return Relationship.prototype.findById(result.id, function(err, relationship) {
              expect(err).to.be(null);
              expect(relationship.from.data.name).to.be.equal('Alice');
              expect(relationship.to.data.name).to.be.equal('Bob');
              return done();
            });
          });
        });
      });
    });
    return it('expect to update a relationship with preventing id accidently changing and with value extending', function(done) {
      return new Node({
        name: 'Alice'
      }).save(function(err, a) {
        return new Node({
          name: 'Bob'
        }).save(function(err, b) {
          return a.createRelationshipTo(b, 'related', {
            since: 'years',
            city: 'Berlin'
          }, function(err, relationship) {
            expect(err).to.be(null);
            return Relationship.prototype.findById(relationship.id, function(err, relationship) {
              expect(relationship.data.since).to.be.equal('years');
              expect(relationship.data.city).to.be.equal('Berlin');
              return relationship.update({
                since: 'months'
              }, function(err, updatedRelationship) {
                var id;

                expect(relationship.data.since).to.be.equal('months');
                expect(relationship.data.city).to.be.equal('Berlin');
                expect(updatedRelationship.data.since).to.be.equal('months');
                expect(updatedRelationship.data.city).to.be.equal('Berlin');
                id = relationship.id;
                relationship.id = -2;
                relationship.data.city = 'Cologne';
                return relationship.save(function(err, updatedRelationship) {
                  expect(err).to.be(null);
                  expect(relationship.id).to.equal(id);
                  expect(updatedRelationship.data.since).to.be.equal('months');
                  expect(updatedRelationship.data.city).to.be.equal('Cologne');
                  expect(relationship.data.since).to.be.equal('months');
                  expect(relationship.data.city).to.be.equal('Cologne');
                  return done();
                });
              });
            });
          });
        });
      });
    });
  });
  return describe('helpers', function() {
    describe('escapeString', function() {});
    describe('cypherKeyValueToString', function() {});
    describe('unflattenObject', function() {});
    describe('flattenObject', function() {});
    describe('sortStringAndOptionsArguments', function() {});
    describe('sortOptionsAndCallbackArguments', function() {});
    describe('sortStringAndCallbackArguments', function() {});
    describe('getIdFromObject', function() {});
    describe('constructorNameOfFunction', function() {
      return it('expect to get the correct constructor name', function() {
        var Person, node, _ref1;

        node = new Node;
        Person = (function(_super) {
          __extends(Person, _super);

          function Person() {
            _ref1 = Person.__super__.constructor.apply(this, arguments);
            return _ref1;
          }

          return Person;

        })(Node);
        var Movie = (function(Node) {

        function Movie() {
          // this is necessary to give the constructed node a name context
          this.init.apply(this, arguments);
        }
        
        _.extend(Movie.prototype, Node.prototype);
        
        Movie.prototype.label = Movie.prototype.constructor_name = 'Movie';

        Movie.prototype.fields = {
          defaults: {
            genre: 'Blockbuster'
          }
        };
        
        return Movie;
      })(Node);
        expect(helpers.constructorNameOfFunction(Movie)).to.be.equal('Movie');
        expect(helpers.constructorNameOfFunction(Person)).to.be.equal('Person');
        return expect(helpers.constructorNameOfFunction(node)).to.be.equal('Node');
      });
    });
    describe('extractAttributesFromCondition', function() {
      return it('expect to extract all attributes from a condition', function() {
        var attrs, condition;

        condition = [
          {
            $and: [
              {
                'n.name': /Alice/i
              }, {
                $or: [
                  {
                    'n.email': "alice@home.com"
                  }, {
                    $and: [
                      {
                        'n.email': "alice@home.de"
                      }, {
                        'n.country': "de_DE"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ];
        attrs = helpers.extractAttributesFromCondition(condition);
        expect(attrs[0]).to.be('name');
        expect(attrs[1]).to.be('email');
        expect(attrs[2]).to.be('country');
        condition = [
          {
            'city': 'Berlin'
          }, {
            $and: [
              {
                'name': /^bob.+/i
              }, {
                $not: [
                  {
                    'name': /^Bobby$/
                  }
                ]
              }
            ]
          }
        ];
        attrs = helpers.extractAttributesFromCondition(condition);
        expect(attrs[0]).to.be('city');
        return expect(attrs[1]).to.be('name');
      });
    });
    return describe('conditionalParameterToString', function() {
      it('expect to leave a string as it is', function() {
        var condition;

        condition = "n.name = 'Alice' AND HAS(n.email)";
        return expect(helpers.conditionalParameterToString(condition)).to.be.equal('( ' + condition + ' )');
      });
      it('expect to transform an key-value object to cypher query', function() {
        var condition, resultShouldBe;

        condition = [
          {
            "n.name": "Alice's"
          }, "HAS(n.email))"
        ];
        resultShouldBe = "( n.name = 'Alice\\'s' AND HAS(n.email)) )";
        return expect(helpers.conditionalParameterToString(condition)).to.be.equal(resultShouldBe);
      });
      it('expect to transform an key-value-object to with $OR and $AND operators', function() {
        var condition, resultShouldBe;

        resultShouldBe = "( ( n.name =~ '(?i)Alice' AND ( n.email = 'alice@home.com' OR ( n.email = 'alice@home.de' AND n.country = 'de_DE' ) ) ) )";
        condition = [
          {
            $and: [
              {
                'n.name': /Alice/i
              }, {
                $or: [
                  {
                    'n.email': "alice@home.com"
                  }, {
                    $and: [
                      {
                        'n.email': "alice@home.de"
                      }, {
                        'n.country': "de_DE"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ];
        return expect(helpers.conditionalParameterToString(condition)).to.be.equal(resultShouldBe);
      });
      return it('expect to transform an key-value-object with identifier', function() {
        var condition, resultShouldBe;

        resultShouldBe = "( ( n.name =~ '(?i)Alice' AND r.since = 'years' AND ( n.email = 'alice@home.com' OR ( n.`email` = 'alice@home.de' AND n.`country` = 'de_DE' ) ) ) )";
        condition = [
          {
            $and: [
              {
                'n.name': /Alice/i
              }, {
                'r.since': 'years'
              }, {
                $or: [
                  {
                    'n.email': "alice@home.com"
                  }, {
                    $and: [
                      {
                        'email': "alice@home.de"
                      }, {
                        'country': "de_DE"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ];
        return expect(helpers.conditionalParameterToString(condition, void 0, {
          identifier: 'n'
        })).to.be.equal(resultShouldBe);
      });
    });
  });
});
