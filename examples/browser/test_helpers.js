// Generated by CoffeeScript 1.6.3
var Graph, Join, Neo4j, Node, client, configForTest, expect, helpers, neo4jmapper, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (typeof root !== "undefined" && root !== null) {
  require('source-map-support').install();
  expect = require('expect.js');
  Join = require('join');
  _ = require('underscore');
  configForTest = require('./config');
  Neo4j = require("../" + configForTest.srcFolder + "/index.js");
  _ref = new Neo4j(configForTest.neo4jURL), Graph = _ref.Graph, Node = _ref.Node, helpers = _ref.helpers, client = _ref.client;
} else if (typeof window !== "undefined" && window !== null) {
  configForTest = _.extend({
    doLog: false,
    wipeDatabase: false,
    neo4jURL: 'http://yourserver:0000/',
    startInstantly: false
  }, configForTest || {});
  Join = window.Join;
  neo4jmapper = Neo4jMapper.init(configForTest.neo4jURL);
  Graph = neo4jmapper.Graph, Node = neo4jmapper.Node, helpers = neo4jmapper.helpers, client = neo4jmapper.client;
  Neo4j = Neo4jMapper.init;
}

describe('Neo4jMapper (helpers)', function() {
  it('escapeString', function() {
    var s;
    s = helpers.escapeString("'a test's'");
    expect(s).to.be.equal("a test\\'s");
    s = helpers.escapeString('"a test\'s"');
    expect(s).to.be.equal("a test\\'s");
    s = helpers.escapeString('a test\'s');
    expect(s).to.be.equal("a test\\'s");
    return expect(helpers.escapeString({})).to.be.an('object');
  });
  it('sortStringAndCallbackArguments', function() {
    var callback, string, _ref1, _ref2;
    _ref1 = helpers.sortStringAndCallbackArguments('string', function() {}), string = _ref1.string, callback = _ref1.callback;
    expect(string).to.be.equal('string');
    expect(callback).to.be.a('function');
    _ref2 = helpers.sortStringAndCallbackArguments(function() {}), string = _ref2.string, callback = _ref2.callback;
    expect(string).to.be(null);
    return expect(callback).to.be.a('function');
  });
  it('sortStringAndOptionsArguments', function() {
    var options, string, _ref1, _ref2, _ref3;
    _ref1 = helpers.sortStringAndOptionsArguments('string', {
      option: true
    }), string = _ref1.string, options = _ref1.options;
    expect(string).to.be.equal('string');
    expect(options.option).to.be.equal(true);
    _ref2 = helpers.sortStringAndOptionsArguments({
      option: true
    }), string = _ref2.string, options = _ref2.options;
    expect(string).to.be(null);
    expect(options.option).to.be.equal(true);
    _ref3 = helpers.sortStringAndOptionsArguments('string'), string = _ref3.string, options = _ref3.options;
    expect(string).to.be.equal('string');
    return expect(Object.keys(options)).to.have.length(0);
  });
  it('sortOptionsAndCallbackArguments', function() {
    var callback, options, _ref1, _ref2;
    _ref1 = helpers.sortOptionsAndCallbackArguments({
      option: true
    }, function() {}), options = _ref1.options, callback = _ref1.callback;
    expect(callback).to.be.a('function');
    expect(options.option).to.be.equal(true);
    _ref2 = helpers.sortOptionsAndCallbackArguments(function() {}), options = _ref2.options, callback = _ref2.callback;
    expect(callback).to.be.a('function');
    return expect(Object.keys(options)).to.have.length(0);
  });
  describe('constructorNameOfFunction', function() {
    return it('expect to get the correct constructor name', function() {
      var Person, node, _ref1;
      node = new Node;
      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Person;

      })(Node);
      var Movie = (function(Node) {

      function Movie() {
        // this is necessary to give the constructed node a name context
        this.init.apply(this, arguments);
      }
      
      _.extend(Movie.prototype, Node.prototype);
      
      Movie.prototype.label = Movie.prototype.constructor_name = 'Movie';

      Movie.prototype.fields = {
        defaults: {
          genre: 'Blockbuster'
        }
      };
      
      return Movie;
    })(Node);
      expect(helpers.constructorNameOfFunction(Movie)).to.be.equal('Movie');
      expect(helpers.constructorNameOfFunction(Person)).to.be.equal('Person');
      return expect(helpers.constructorNameOfFunction(node)).to.be.equal('Node');
    });
  });
  describe('extractAttributesFromCondition', function() {
    return it('expect to extract all attributes from a condition', function() {
      var attrs, condition;
      condition = [
        {
          $and: [
            {
              'n.name': /Alice/i
            }, {
              $or: [
                {
                  'n.email': "alice@home.com"
                }, {
                  $and: [
                    {
                      'n.email': "alice@home.de"
                    }, {
                      'n.country': "de_DE"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ];
      attrs = helpers.extractAttributesFromCondition(condition);
      expect(attrs[0]).to.be('name');
      expect(attrs[1]).to.be('email');
      expect(attrs[2]).to.be('country');
      condition = [
        {
          'city': 'Berlin'
        }, {
          $and: [
            {
              'name': /^bob.+/i
            }, {
              $not: [
                {
                  'name': /^Bobby$/
                }
              ]
            }
          ]
        }
      ];
      attrs = helpers.extractAttributesFromCondition(condition);
      expect(attrs[0]).to.be('city');
      return expect(attrs[1]).to.be('name');
    });
  });
  return describe('conditionalParameterToString', function() {
    it('expect to leave a string as it is', function() {
      var condition;
      condition = "n.name = 'Alice' AND HAS(n.email)";
      return expect(helpers.conditionalParameterToString(condition)).to.be.equal('( ' + condition + ' )');
    });
    it('expect to transform an key-value object to cypher query', function() {
      var condition, resultShouldBe;
      condition = [
        {
          "n.name": "Alice's"
        }, "HAS(n.email))"
      ];
      resultShouldBe = "( n.name = 'Alice\\'s' AND HAS(n.email)) )";
      return expect(helpers.conditionalParameterToString(condition)).to.be.equal(resultShouldBe);
    });
    it('expect to transform an key-value-object to with $OR and $AND operators', function() {
      var condition, resultShouldBe;
      resultShouldBe = "( ( n.name =~ '(?i)Alice' AND ( n.email = 'alice@home.com' OR ( n.email = 'alice@home.de' AND n.country = 'de_DE' ) ) ) )";
      condition = [
        {
          $and: [
            {
              'n.name': /Alice/i
            }, {
              $or: [
                {
                  'n.email': "alice@home.com"
                }, {
                  $and: [
                    {
                      'n.email': "alice@home.de"
                    }, {
                      'n.country': "de_DE"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ];
      return expect(helpers.conditionalParameterToString(condition)).to.be.equal(resultShouldBe);
    });
    return it('expect to transform an key-value-object with identifier', function() {
      var condition, resultShouldBe;
      resultShouldBe = "( ( n.name =~ '(?i)Alice' AND r.since = 'years' AND ( n.email = 'alice@home.com' OR ( n.`email` = 'alice@home.de' AND n.`country` = 'de_DE' ) ) ) )";
      condition = [
        {
          $and: [
            {
              'n.name': /Alice/i
            }, {
              'r.since': 'years'
            }, {
              $or: [
                {
                  'n.email': "alice@home.com"
                }, {
                  $and: [
                    {
                      'email': "alice@home.de"
                    }, {
                      'country': "de_DE"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ];
      return expect(helpers.conditionalParameterToString(condition, void 0, {
        identifier: 'n'
      })).to.be.equal(resultShouldBe);
    });
  });
});
